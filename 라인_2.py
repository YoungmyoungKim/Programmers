def solution(answer_sheet, sheets):
    answers=[]
    for i, val in enumerate(sheets):
        str=''
        for j in range(len(val)):
            if answer_sheet[j]==val[j]:
                str+='0'
            else:
                str+=val[j]
        answers.append(str)

    return answers


an_1, sh_1='4132315142', ['3241523133', '4121314445', '3243523133', '4433325251', '2412313253']
an_2, sh_2='53241', ['53241', '42133', '53241', '14354']
an_3, sh_3='24551', ['24553', '24553', '24553', '24553']

print(solution(an_1, sh_1))
print(solution(an_2, sh_2))
print(solution(an_3, sh_3))

'''
객관식 5지선다로 치러진 시험의 답안지가 있습니다. 이때, 어떤 두 응시자가 제출한 답안지에 대해서, 부정행위 가능성 지수는 아래와 같은 방식으로 계산할 수 있습니다.

의심 문항 = 같은 선택지를 골랐으나 오답인 문항
부정행위 가능성 지수 = 총 의심 문항의 수 + (가장 긴 연속된 의심 문항의 수)2
응시자들이 제출한 답안지들 사이에서 가장 높은 부정행위 가능성 지수를 찾아주세요.

제한 사항
answer_sheet는 정답지를 나타냅니다.
answer_sheet는 길이가 1 이상 100 이하인 문자열입니다.
1번 문항의 정답부터 차례대로 저장하고 있습니다.
answer_sheets는 1,2,3,4,5로만 이루어진 문자열입니다.
sheets는 응시자들이 제출한 답안지입니다.
sheets는 원소의 개수가 2 이상 200 이하인 문자열 배열입니다.
sheets의 각 원소는 한 응시자가 제출한 답안을 저장하고 있는 문자열입니다.
sheets의 모든 원소의 길이는 answer_sheet의 길이와 같습니다.
즉, 응시자 수(=sheets의 원소 개수)는 2명 이상 200명 이하이고, 문항의 수(=sheets의 각 원소의 길이=answer_sheet의 길이)는 1개 이상 100개 이하입니다.
sheets의 모든 원소는 1,2,3,4,5로만 이루어진 문자열입니다.
모든 답안지들 사이에서 가장 높은 부정행위 가능성 지수를 찾아서 return 해주세요.

입출력 예
answer_sheet	sheets	result
"4132315142"	["3241523133","4121314445","3243523133","4433325251","2412313253"]	17
"53241"	["53241", "42133", "53241", "14354"]	0
"24551"	["24553", "24553", "24553", "24553"]	2
'''
